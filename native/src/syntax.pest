// Helper
escape = _{ "\\" ~ (!(NEWLINE | ASCII_HEX_DIGIT) ~ ANY | ASCII_HEX_DIGIT{1,6}) }
single_line_comment = _{ "//" ~ (!NEWLINE ~ ANY)* }
comma = _{ ws ~ "," ~ ws }
ident = _{ (ASCII_ALPHA | "-"{1,2} | "_" | escape) ~ (ASCII_ALPHANUMERIC | "-"{1,2} | "_" | escape)* }
ws = _{ WHITE_SPACE* }
nl = _{ ("\t" | " ")* ~ NEWLINE }

// Base expressions
symbol = { ident }
multi_line_comment = { "/*" ~ (!"*/" ~ ANY)* ~ "*/" }
func = { ident }
func_w = _{ func ~ "(" }
atrule = { ident }
atrule_w = { "@" ~ atrule }
hash = { ASCII_HEX_DIGIT{1,6} }
hash_w = _{ "#" ~ hash }
number = { 
	(
		("+" | "-")? ~
		(ASCII_DIGIT+ ~ ("." ~ ASCII_DIGIT+)? | "." ~ ASCII_DIGIT+)
	) ~
	(^"e" ~ ("+" | "-")? ~ ASCII_DIGIT+)?
}
single_string = { ("\\'" | "\\" ~ NEWLINE | !("'" | NEWLINE) ~ ANY)* }
double_string = { ("\\\"" | "\\" ~ NEWLINE | !("\"" | NEWLINE) ~ ANY)* }
string_w = _{
	("\"" ~ double_string ~ "\"")
	| ("'" ~ single_string ~ "'")
}
unit = { "%" | ASCII_ALPHA+ }
dimension = { number ~ unit }
var = { ident? }
var_w = _{ "$" ~ var }

// Composite expressions
surround = { (ASCII_ALPHANUMERIC | "." | "-" | "_" | "#" | "@" | escape)+ }
interpolation = {
	surround? ~
	(
		"{" ~ ws ~ expr ~ ws ~ "}" ~
		surround?
	)+
}
tuple = { (operation | value) ~ (("\t" | " ")+ ~ (operation | value))+ }
object_accessor = { var_w ~ ("." ~ symbol)+ }
object = {
	"{" ~
	(
		ws ~ symbol ~ 
		ws ~ ":" ~
		ws ~ expr ~
		nl
	)* ~
	ws ~ "}"
}
array_accessor = { var_w ~ "[" ~ ws ~ expr ~ ws ~ "]" }
array = {
	(operation | parens | tuple | value) ~
	(
		ws ~ "," ~
		ws ~ (operation | parens | tuple | value)
	)+
}
arg = { operation | parens | tuple | value }
function_call = { func_w ~ ws ~ (array | arg) ~ ws ~ ")" }

// Operations
op_1_symbol = { "++" }
op_1 = {
	(parens | op_2 | op_3 | op_4 | value) ~ ws ~
	op_1_symbol ~ ws ~
	(op_1 | parens | op_2 | op_3 | op_4 | value)
}
op_2_symbol = { "..=" | ".." }
op_2 = {
	(parens | op_3 | op_4 | value) ~ ws ~
	op_2_symbol ~ ws ~
	(op_2 | parens | op_3 | op_4 | value)
}
op_3_symbol = { "+" | "-" }
op_3 = {
	(parens | op_4 | value) ~ ws ~
	op_3_symbol ~ ws ~
	(op_3 | parens | op_4 | value)
}
op_4_symbol = { "*" | "/" }
op_4 = {
	(parens | value) ~ ws ~
	op_4_symbol ~ ws ~
	(op_4 | parens | value)
}
operation = _{ op_1 | op_2 | op_3 | op_4 }

// Lines
var_def = { var_w ~ ws ~ "=" ~ ws ~ expr }
for_loop = { 
	"for" ~ WHITE_SPACE+ ~ var_w ~ WHITE_SPACE+ ~
	"in" ~ WHITE_SPACE+ ~ expr ~ nl ~
	PEEK_ALL ~ PUSH(indent) ~ line ~
	(PEEK_ALL ~ line)* ~
	DROP
}
ret = { "return" ~ WHITE_SPACE+ ~ expr }

// Enums
value = _{
	object_accessor | object | array_accessor | function_call |
	interpolation | dimension | symbol | hash_w | number | string_w | var_w
}
parens = _{ "(" ~ ws ~ expr ~ ws ~ ")" }
expr = _{ operation | parens | array | tuple | value }
line = { var_def | for_loop | ret }

// Selectors
indent = _{ "\t" | "    " | "  " | " " }
sel_bit = _{ ("&" | "/" | "." | "#" | ":" | ident | ("[" ~ ANY* ~ "]"))+ }
sel = { sel_bit ~ (("\t" | " ")* ~ (sel_bit | ">"))* }
property = {
	symbol ~ ws ~
	": " ~ ws ~ expr ~
	("\t" | " ")* ~
	NEWLINE?
}
mixin_call = {
	func_w ~ ws ~
	(array | arg) ~ ws ~ ")" ~ 
	("\t" | " ")* ~
	NEWLINE?
}

// Nodes
selector = {
	sel ~ (comma ~ sel)* ~ ("\t" | " ")* ~ NEWLINE ~
	(
		PEEK_ALL ~ PUSH(indent) ~ line ~ NEWLINE ~
		(PEEK_ALL ~ line ~ NEWLINE)* |
		PEEK_ALL ~ PUSH(indent) ~ (property | mixin_call | selector)
	) ~
	(nl | PEEK_ALL ~ (property | mixin_call | selector))* ~
	DROP
}
mixin = {
	func_w ~ ws ~
	symbol ~ (comma ~ symbol)* ~ ws ~ ")" ~ NEWLINE ~
	(
		PEEK_ALL ~ PUSH(indent) ~ line ~ NEWLINE ~
		(PEEK_ALL ~ line ~ NEWLINE)* |
		PEEK_ALL ~ PUSH(indent) ~ property
	) ~
	(nl | PEEK_ALL ~ property)* ~
	DROP
}
function = {
	"fn" ~ WHITE_SPACE+ ~ func_w ~ ws ~
	symbol ~ (comma ~ symbol)* ~ ws ~ ")" ~ NEWLINE ~
	PEEK_ALL ~ PUSH(indent) ~ line ~ NEWLINE ~
	(PEEK_ALL ~ line ~ NEWLINE)* ~
	DROP
}

// Root
node = _{ single_line_comment | multi_line_comment | line | selector | mixin | function }
file = _{
    SOI ~
    NEWLINE* ~
    (node ~ NEWLINE*)* ~
    EOI
}
